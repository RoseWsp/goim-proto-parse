# 关于粘包 

- 粘包原因 
- 粘包解法 

## 粘包原因
**发送端**：对于小包，会采用`Nagle`算法合并小包，旨在减少网络中小包数量，提高传输效率。 
那这会天然的 产生粘包现在。多个包粘在一起了   
**接收端**： 通常接收端会用一个buffer接收数据包，然后应用程序一次性读取buffer,
那这个时候buffer 里就有可能存在多个包，自然的会出现上一个包尾和下一个包头连在一起。 

## 粘包解法
**fix length / delimiter based / length field based frame decoder**

### **fix length**
约定发送端和接收端，发送和接收相同长度数据包即可。 
这种做法，编码容易实现，但容易出现浪费，譬如定长是10个字节，发送端只发1个字节，余下的9个字节填充0值，其实想想挺浪费的。 

尝试列举应用场景： 
我想类似于发送信号类的场景可以用，譬如 ping 、talent 可以用fix length 
甚至 iot 设备上报信号，也可以用fix length .

### **delimiter based**
在消息末尾添加特殊符号，这样就可以识别消息的边界了。 
这样做相对简单，收发两端要对消息分界的特殊符号做转义处理如果数据包中包含这个特殊符号。 

尝试列举应用场景： 
可以应用于 消息内容格式固定，然后又是变长的，这样可以用 delimiter based ,

### **length field based frame decoder** 
封装数据包协议，大体上将数据包分为 消息头+消息体。 在消息头中定义长度字段，来标识消息的总长度 。读取消息时，拿到整个消息长度，就能识别出消息边界，不会出现粘包现象。 当然优点是自适应强，消息可变长，消息内容可多种多样，不用在乎 delimiter based ,还要对消息分界特殊符转义。 当然成本是，编码相对复杂，需要按照协议解析消息内容，识别出包头各个字段的作用，当然功能更强

尝试列举应用场景： 
譬如 Goim ,rpc 通信协议 dubbo 等等。 

